import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;


public class Scanner {
	
	private Options options;
	private CommandLineParser parser;
	private ExecutorService executor;

	public Scanner() {
		options = new Options();
		options.addOption("i", true, "Path to Minecraft mod .jar");
		options.addOption("l", true, "Path to Minecraft install directory");
		parser = new DefaultParser();
		executor = Executors.newCachedThreadPool();
	}
	
	private CommandLine getCommands(String[] args) throws ParseException{
		return parser.parse(options, args);
	}
	
	private List<String> getClassNames(File jarFile){
		ArrayList<String> classNames = new ArrayList<String>();
		JarInputStream jarStream = null;
		try {
			jarStream = new JarInputStream(new FileInputStream(jarFile));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		JarEntry jar;
		try {
			while((jar = jarStream.getNextJarEntry()) != null){
				if(jar.getName().endsWith(".class")){
					String className = jar.getName();
					className = className.replaceAll(".class", "");
					className = className.replaceAll("/", ".");
					classNames.add(className);
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			jarStream.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return classNames;
	}
	
	private void executeClassMethods(File jarFile, String className, String libPath){
		try {
//			Set<String> jars = getJarsInDirectory(new File("/home/michael/.minecraft"));
//			Set<String> jars = getJarsInDirectory(new File("/home/cuckoo/.minecraft"));
			Set<String> jars = getJarsInDirectory(new File(libPath));
			ArrayList<URL> urlList = new ArrayList<URL>();
			for(String jarLocation : jars){
				urlList.add(new URL("jar:file:"+jarLocation+"!/"));
			}
			URL[] urls = new URL[urlList.size() + 1];// = { new URL("jar:file:" + jarFile.getAbsolutePath()+"!/") };
			for(int i = 0; i<urlList.size(); i++){
				urls[i] = urlList.get(i);
			}
			urls[urlList.size()] = new URL("jar:file:" + jarFile.getAbsolutePath()+"!/");
			URLClassLoader cl = URLClassLoader.newInstance(urls);
			Class c = cl.loadClass(className);
			HashSet<Method> methods = new HashSet<Method>();
			for(Method m : c.getMethods()){
				methods.add(m);
			}
			for(Method m : c.getDeclaredMethods()){
				methods.add(m);
			}
			for(Method m : methods){
				m.setAccessible(true);
				int numParameters = m.getParameterTypes().length;
				if(numParameters == 0){
					ClassMethodExecutor methodExecutorTask = new ClassMethodExecutor(c, m, className);
					executor.submit(methodExecutorTask);
//					try {
//						System.out.println("Attempting to execute method: "+m.getName());
//						Object obj = c;
//						if(Modifier.isStatic(m.getModifiers())){
//							obj = null;
//						}
//						m.invoke(obj);
//					} catch (IllegalAccessException e) {
//						System.out.println("IllegalAccessException when executing method: "+m.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
//					} catch (IllegalArgumentException e) {
//						System.out.println("IllegalArgumentException when executing method: "+m.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
//					} catch (InvocationTargetException e) {
//						System.out.println("InvocationTargetException when executing method: "+m.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
//					} catch (Exception e){
//						System.out.println(e.getClass().getName()+" when executing method: "+m.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
//					}
				}
			}
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClassNotFoundException | NoClassDefFoundError e) {
			// TODO Auto-generated catch block
			//e.printStackTrace();
			System.out.println("Could not find class. Error details: "+getStackTraceString(e));
			return;
		}
	}
	
	private void jarsInDirRecur(File dir, Set<String> jars){
		try{
			File[] files = dir.listFiles();
			for(File file : files){
				if(file.isDirectory()){
					jarsInDirRecur(file, jars);
				} else{
					if(file.getAbsolutePath().endsWith(".jar")){
						jars.add(file.getAbsolutePath());
					}
				}
			}
		} catch(NullPointerException e){
			System.out.println("Null pointer exception? dir: "+dir.toString()+" jars: "+jars.toString());
			e.printStackTrace();
		}
	}
	
	private Set<String> getJarsInDirectory(File dir){
		Set<String> jarSet = new HashSet<String>();
		jarsInDirRecur(dir, jarSet);
		return jarSet;
	}
	
	private String getStackTraceString(Throwable e){
		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		e.printStackTrace(pw);
		return sw.toString();
	}
	
	private static boolean checkHasExtension(File file, String extension){
		String filePath = file.getAbsolutePath();
		return filePath.endsWith(extension);
	}
	
	public static void main(String[] args){
		Scanner scanner = new Scanner();
		CommandLine cmds;
		try {
			cmds = scanner.getCommands(args);
		} catch (ParseException e) {
			System.out.println("Could not parse command line arguments. Error:\n" + e.getStackTrace());
			return;
		}
		String modPath = null;
		if((modPath = cmds.getOptionValue("i")) == null){
			System.out.println("Need to provide a path to the Minecraft mod .jar");
			return;
		}
		String libPath = null;
		if((libPath = cmds.getOptionValue("l")) == null){
			System.out.println("Need to provide a path to the Minecraft install directory");
			return;
		}
		File modFile = new File(modPath);
		if(!modFile.exists() || modFile.isDirectory()){
			System.out.println("Could not find mod at provided path");
			return;
		}
		if(!checkHasExtension(modFile, ".jar")){
			System.out.println("File does not have .jar extension");
			return;
		}
		// /home/michael/.minecraft/mods/test-1.0.jar
		List<String> classNames = scanner.getClassNames(modFile);
		System.out.println("Class names:");
		for(String name : classNames){
			System.out.println(name);
		}
		System.out.println("Executing methods with no arguments");
		for(String name : classNames){
			System.out.println("Executing class: "+name+"\n------------------------------------------------------------------------------------");
			scanner.executeClassMethods(modFile, name, libPath);
		}
		
		boolean timeout;
		try {
			timeout = scanner.executor.awaitTermination(10, TimeUnit.SECONDS);
			if(timeout){
				System.out.println("Executor did no timeout");
			} else{
				System.out.println("Executor did timeout");
			}
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.exit(0);
	}
	
	private class ClassMethodExecutor implements Runnable{
		
		private Object classObj;
		private Method method;
		private String className;
		
		public ClassMethodExecutor(Object classObj, Method method, String className) {
			this.classObj = classObj;
			this.method = method;
			this.className = className;
		}

		@Override
		public void run() {
			try {
				System.out.println("Attempting to execute method: "+method.getName());
				Object obj = classObj;
				if(Modifier.isStatic(method.getModifiers())){
					obj = null;
				}
				method.invoke(obj);
			} catch (IllegalAccessException e) {
				System.out.println("IllegalAccessException when executing method: "+method.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
			} catch (IllegalArgumentException e) {
				System.out.println("IllegalArgumentException when executing method: "+method.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
			} catch (InvocationTargetException e) {
				System.out.println("InvocationTargetException when executing method: "+method.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
			} catch (Exception e){
				System.out.println(e.getClass().getName()+" when executing method: "+method.getName()+" in class: "+className);//+"\nError details:\n"+getStackTraceString(e));
			}
			
		}
		
	}
	
}


