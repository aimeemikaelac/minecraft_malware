'''
Created on Oct 30, 2015

@author: michael
'''

from Queue import Queue
import base64
import bson
from flask import Flask, url_for, request, redirect, g
from flask.helpers import send_file
from flask.templating import render_template
import json
import os
import pickle
import pika
import pymongo
import requests
import shlex
import sqlite3
import subprocess
import tempfile
from threading import Thread
from werkzeug.utils import secure_filename
import argparse

from AnalysisTask import AnalysisTask
from AtomicCounter import AtomicCounter
from config import *
from strace_analyzer import Strace_Analyzer
from util import get_timestamp


#global config variables stored in config.py
app = Flask(__name__)
# reports_table = dict()
global upload_queue
upload_queue = Queue()
global pending_tasks
pending_tasks = AtomicCounter()
global mongo_client
mongo_client = pymongo.MongoClient(MONGOURI)
global handler_threads
handler_threads = []
global task_finished_consumer_threads
task_finished_consumer_threads = []

def task_finished_consumer_thread():
    print 'starting task complete callback thread'
    connection = pika.BlockingConnection(pika.ConnectionParameters(
        host=RABBITMQ))
    channel = connection.channel()
    channel.queue_declare(queue='task_finished')
    channel.basic_consume(task_finished_consumer_callback,
                      queue='task_finished',
                      no_ack=True)
    channel.start_consuming()
    
def task_finished_consumer_callback(ch, method, properties, body):
    print 'received task complete callback'
    global pending_tasks
    pending_tasks.decrement()
    ch.basic_ack(delivery_tag = method.delivery_tag)
    #TODO: do more here. will include the mongodb record id in the message
    #TODO: clear the running modules field for the mod in the database
    body_dict = eval(body)
    file_hash = body_dict['file_hash']
    db = mongo_client.minecraft
    update_record = {"file_hash":file_hash}
    update_request = {"$set": {"finished":"True"}}
    db.mods.update_one(update_record, update_request)
    
    if pending_tasks.get() < 0:
        #TODO: handle when more tasks were finished then we sent. should not happen
        raise ValueError


def process_file_thread():
    print 'starting file processor thread'
    connection = pika.BlockingConnection(pika.ConnectionParameters(
        host=RABBITMQ))
    channel = connection.channel()
    channel.queue_declare(queue='cuckoo_modules_queue')
    db = mongo_client.minecraft
    while True:
        #TODO: have a rabbit consumer that recieves completed tasks that decrements this counter
        global pending_tasks
        pending_tasks.increment()
        currentTask = upload_queue.get(block=True)
        print 'dequeueded a file'
        #use the hash of the file as the key
        matching_mods = db.mods.find({"file_hash":currentTask.file_hash})
        if matching_mods.count() > 1:
            #TODO: handle when mulitple objects in the db have the same primary key/hash, which should be impossible
            raise ValueError
        elif matching_mods.count() == 1:
            #TODO: handle when there is a matching mod in the DB - this is possible, and very likely if there are re-uploads
#             for doc in matching_mods:
#                 print doc
            print 'record already exists'
        else:
            print 'no matching records'
            mod_record = {}
            mod_record['_id'] = currentTask.file_hash
            mod_record['file_hash'] = currentTask.file_hash
            mod_record['finished'] = 'false'
            mod_record['file_name'] = currentTask.file_name
            mod_record['received_timestamp'] = currentTask.timestamp
            mod_record['finished_timestamp'] = ''
            #TODO: support larger files than the 16 MB BSON limit in mongodb
            #for now, store as binary data and reconstruct in the rabbitmq consumer
            with open(currentTask.file_path, 'r') as mod_file:
                data = mod_file.read()
                b64 = base64.b64encode(data)
                mongo_data = bson.binary.Binary(b64)
                mod_record['file'] = mongo_data
            for module in currentTask.cuckoo_modules:
                if module in CUCKOO_MODULES:
                    version = CUCKOO_MODULES[module]
                else:
                    version = 'NaN'
                mod_record[module] = {'version':version, 
                                      'finished':'False', 
                                      'report':'', 
                                      'finished_timestamp':''}
            mod_record['running_modules'] = currentTask.cuckoo_modules
            result = db.mods.insert_one(mod_record)
            print 'inserted a record for this file'
            for module in currentTask.cuckoo_modules:
                message = "{{'record':'{0}','module':'{1}','hash':'{2}'}}".format(result.inserted_id, module, currentTask.file_hash)
                channel.basic_publish(exchange='',
                                      routing_key='cuckoo_modules_queue',
                                      body=message,
                                      properties=pika.BasicProperties(
                                      delivery_mode = 2, # make message persistent
                                      ))
                print 'wrote file to rabbitmq'

def setup_app():
#     #TODO: instead, populate this dict using the database
#     if os.path.exists(REPORT_TABLE_OBJ_FILENAME):
#         reports_table = pickle.load(REPORT_TABLE_OBJ_FILENAME)
    for i in range(HANDLERS):
        currentThread = Thread(target=process_file_thread)
        handler_threads.append(object)
        currentThread.start()
        
    for i in range(TASK_FINISHED_CONSUMERS):
        currentThread = Thread(target=task_finished_consumer_thread)
        handler_threads.append(object)
        currentThread.start()
    

setup_app()
app.config['REPORT_TABLE_OBJ_FILENAME'] = REPORT_TABLE_OBJ_FILENAME
app.config['ALLOWED_EXTENSIONS'] = ALLOWED_EXTENSIONS

# def connect_to_database():
#     #TODO: make the database connection more secure maybe? All the data 
#     #in the database will be public anyway, but maybe?
#     db = sqlite3.connect(DATABASE)
#     db.execute('CREATE table if not exists AnalyisFiles ()')
#     return 
# 
# def get_db():
#     db = getattr(g, '_database', None)
#     if db is None:
#         db = g._database = connect_to_database()
#     return db
# 
# @app.teardown_appcontext
# def close_connection(exception):
#     db = getattr(g, '_database', None)
#     if db is not None:
#         db.close()

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS

@app.route('/upload', methods=['GET', 'POST'])
def upload_file():
    #TODO: need to be able to choose the minecraft version here - will also
    #need to add version support to the analysis modules
    if pending_tasks.get() < MAXIMUM_TASKS:
        if request.method == 'POST':
            print 'received file'
            file = request.files['file']
            if file and allowed_file(file.filename):
                print 'allowed file'
                filename = secure_filename(file.filename)
                tempfolder = tempfile.mkdtemp()
                file.save(os.path.join(tempfolder, filename))
                filepath = tempfolder + "/" + filename
                file_hash = process_file(filename, filepath)
                return redirect(url_for('printReport',
                                        analysisKey=file_hash))
            else:
                return "Illegal file type"
        return '''
        <!doctype html>
        <title>Upload new File</title>
        <h1>Upload new File</h1>
        <form action="" method=post enctype=multipart/form-data>
          <p><input type=file name=file>
             <input type=submit value=Upload>
        </form>
        '''
    else:
        return '''
        <!doctype html>
        <title>Upload new File</title>
        <p>Currently at the maximum number of pending tasks. Please try again later</p>
        '''
        

# def updateTableEntry(analysisKey, report):
#     print 'updating entry'
#     if analysisKey in reports_table:
#         print 'not in table'
#         reports_table[analysisKey].append(report)
#         print 'added to table'
#     else:
#         reports_table[analysisKey] = list([report])
# #     pickle.dump(reports_table, app.config['REPORT_TABLE_OBJ_FILENAME'])
 
def process_file(filename, filepath):
    #TODO: assume that cuckoo is already running. In future, maybe launch with the server
    #TODO: support for different cuckoo VMs/OSes
#     processor_modules = ['Strace_Analyzer()']
#     print 'processing'
#     for analyzer_str in processor_modules:
#         analyzer = eval(analyzer_str)
#         print 'evalled'
#         output = analyzer.run_analyzer(filepath)
#         print 'eval finished'
#         updateTableEntry(filename, output)
#     cuckoo_modules = ['classloader']
    #here are a list of classes that process the results of the cuckoo execution
    #each class implements a 'process' function that takes the result number and cuckoo
    #dir as arguments and return an AnalysisOutput object for storage
#     cuckoo_postprocessors = ['Classloader_Processor()']
#     SUBMISSION_PATH = '/tasks/create/file'
#     for cuckoo_module in cuckoo_modules:
#         cuckoo_call_tokens = [CUCKOO_DIR+'/utils/submit.py', '--package', cuckoo_module, filepath]
#         cuckoo_call_str = " ".join(cuckoo_call_tokens)
#         cuckoo_shell_args = shlex.split(cuckoo_call_str)
#         #this submits to the running cuckoo instance if there is one
#         subprocess.call(cuckoo_shell_args)
        #Instead, use the REST API. assumes the cuckoo REST server is running
#         with open(filepath, 'rb') as sample:
#             multipart_file = {"file:": (filename, sample)}
#             request = requests.post(CUCKOO_API+SUBMISSION_PATH, files=multipart_file, package=cuckoo_module)
#             
#         json_decoder = json.JSONDecoder()
#         task_id = json_decoder.decode(request.text)["task_id"]
#         updateTableEntry(filename, None)
    task = AnalysisTask(filename, filepath, CUCKOO_MODULES.keys(), get_timestamp())
    upload_queue.put(task)
    return task.file_hash

                

    
 
@app.route('/')
def hello_world():
    message = 'Hello! Please upload a minecraft jar here:'
    message += "<br /><a href=\"" + str(url_for('upload_file')) +"\">Upload file</a>"
    message += '<br />Please note that we only support modes for Minecraft version 1.8.7. More version support to come.'
    return message

@app.route('/reports/<analysisKey>')
def printReport(analysisKey):
    db = mongo_client.minecraft
    all_mods = db.mods.find({'file_hash':analysisKey})
    if all_mods.count() == 0:
        return 'No such record'
    #TODO: handle multiple records. for now, just take the first
    mod = all_mods[0]
    modules = {}
    for key in mod.keys():
            if 'version' in mod[key]:
                modules[key] = mod[key]
    
    
    return render_template("report.html", title=mod['file_name'], mod=mod, modules=modules)
    
    
#     if analysisKey in reports_table:
#         reportList = reports_table[analysisKey]
#         if reportList is None:
#             return "Analysis not completed"
#         sorted_reports = sorted(reportList, key=lambda x: x.analysisString)
#         message = ""
#         for report in sorted_reports:
#             message += str(report.analysisString)
#             message += "\n"
#             message += str(report.messageList)
#         return message
#     else:
#         return "Report does not exist"

@app.route('/reports/<analysisKey>/reportFile/<module>')
def sendReport(analysisKey, module):
    db = mongo_client.minecraft
    all_mods = db.mods.find({'file_hash':analysisKey})
    if all_mods.count() == 0:
        return 'No such record'
    #TODO: handle multiple records. for now, just take the first
    mod = all_mods[0]
    if module not in mod.keys():
        return 'No such module'
    if mod[module]['finished'] == 'False':
        return 'Anslysis not finished'
    fd, path = tempfile.mkstemp()
    try:
        with open(path, 'w') as tmp:
            file_data = mod[module]['report']
            data = base64.b64decode(file_data)
            report_name = mod['file_name']+module+".tar.bz2"
            tmp.write(data)
        return send_file(path, as_attachment=True, attachment_filename=report_name)
    finally:
        os.remove(path)

    

@app.route('/reports')
def reports():
    db = mongo_client.minecraft
    all_mods = db.mods.find({})
    modules = []
    all_mods_list = []
    for mod in all_mods:
        print mod['file_hash']
        all_mods_list.append(mod)
        for key in mod.keys():
            if 'version' in mod[key]:
                modules.append(mod[key])
    
    print all_mods.count()
    
    return render_template("reports.html", all_mods=all_mods_list, modules=modules)
#     message = 'Reports:'
#     for report_key in reports_table:
#         if reports_table[report_key] is None:
#             message += '<br />Analysis not complete'
#         else:
#             message += "<br />" + str(url_for(printReport, report=report_key))
#     return message
        
    

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("--external", help="Allow external connections", action='store_true')
    parser.add_argument("--port", help="Listen on this port", default=5000)
    args = parser.parse_args()
    
    if args.external:
        app.run('0.0.0.0', port=args.port)
    else:
        app.run(debug=True, port=args.port)
    
    
    
    
    
    
    
    