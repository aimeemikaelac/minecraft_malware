'''
Created on Feb 14, 2016

@author: michael
'''
import base64
import bson
import json
from multiprocessing import Process
import os
import pika
import pymongo
import requests
import tempfile
from threading import Thread
from time import sleep
from util import get_timestamp

from config import RABBITMQ, MONGOURI, CUCKOO_API, SUBMISSION_PATH
from util import get_timestamp


handler_processes = []


def cuckoo_module_consume_callback(ch, method, properties, body):
    #message body is of the form: "{{'record':{0},'module':'{1}','hash':'{2}'}}".format(result.inserted_id, module, currentTask.file_hash)
    #need to parse for the record and the cuckoo module to run
    #then need to get the file out of the database, save to a temp file and call the cuckoo api
    print 'beginning cuckoo module consumer'
    mongo_client = pymongo.MongoClient(MONGOURI)
    db = mongo_client.minecraft
    body_dict = eval(body)
    record = body_dict['record']
    module = body_dict['module']
    file_hash = body_dict['hash']
    
    matching_mods = db.mods.find({"file_hash":file_hash})
    if matching_mods.count() > 1:
        #TODO: handle this. should not occur where we have multiple entries with the same hash
        raise ValueError
    elif matching_mods.count() == 0:
        #TODO: handle if there is no matching record - most likely will not happen, but might? for now, just give up,
        #since we have no way of getting the mod file without a record
        print 'could not find record for hash: '+str(hash)
    else: 
        print 'got a matching record'
        mod_record = matching_mods[0]
        file_data = mod_record['file']
        data = base64.b64decode(file_data)
        file_name = mod_record['file_name']
#         fd, path = tempfile.mkstemp()
#         print path
#         try:
#             with open(path, 'w') as tmp:
                # do stuff with temp file
#                 tmp.write(data)
#                 with open(path, 'r') as tmp2:        
#                     multipart_file = {"file":(file_name, tmp2), "package":module}
        multipart_file = {"file":(file_name, data)}
        rest_url = CUCKOO_API+SUBMISSION_PATH
        #TODO: these options need to be associated with the list of modules
        request = requests.post(rest_url, files=multipart_file, data={"package":module, 'options':"minecraft=~/.minecraft,scanner=~/scanner.jar"})
        print 'wrote file to cuckoo'
        json_decoder = json.JSONDecoder()
        task_id = json_decoder.decode(request.text)["task_id"]
        p = Process(target=cuckoo_task_handler_process_task, args=(task_id, file_hash, module,))
        handler_processes.append(p)
        p.start()
        print 'start watcher process for task' + str(task_id)
#         finally:
#             print 'temp file path' + path
#             os.remove(path)
        
    ch.basic_ack(delivery_tag = method.delivery_tag)
    
def cuckoo_task_handler_process_task(task_id, file_hash, module):
    print 'stating task handler watcher process'
    VIEW_PATH = "/tasks/view/"
    view_url = CUCKOO_API+VIEW_PATH+str(task_id)
    task_finished = False
    json_decoder = json.JSONDecoder()
    
    while task_finished is False:
        request = requests.get(view_url)
#         print 'request text:\n'+str(request.text)
        data = json_decoder.decode(request.text)
#         print 'json data:\n'+str(data)
        if data['task']['status'] == 'reported':
            task_finished = True
        else:
            sleep(1)
            
    print 'task has \'reported\' state'
            
    REPORT_PATH = "/tasks/report/"
    report_url = CUCKOO_API+REPORT_PATH+str(task_id)+"/all"
    request = requests.get(report_url)
    report = request.content
    
    report64 = base64.b64encode(report)
    report64bin = bson.binary.Binary(report64)
    
    local_mongo = pymongo.MongoClient(MONGOURI)
    local_db = local_mongo.minecraft
    
    update_record = {"file_hash":file_hash}
    update_request = {"$set": {str(module)+".finished":"True",
                               str(module)+".report":report64bin,
                               str(module)+".finished_timestamp":get_timestamp() }}
    
    print 'updated record with the report data'
    result = local_db.mods.update_one(update_record, update_request)
    
    #now, check if all of the other modules have been completed
    matching_mods = local_db.mods.find({"file_hash":file_hash})
    if matching_mods.count() > 1:
        #TODO: handle this. should not occur where we have multiple entries with the same hash
        raise ValueError
    elif matching_mods.count() == 0:
        #TODO: handle if there is no matching record - most likely will not happen, but might? for now, just give up,
        #since we have no way of getting the mod file without a record
        print 'could not find record for hash: '+str(hash)
    else:
        print 'got a matching record in watcher process'
        mod = matching_mods[0]
        running_mods = mod['running_modules']
        all_finished = True
        for module in running_mods:
            if mod[module]['finished'] == 'False':
                all_finished = False
                break
        
        print 'all modules finished'
        if all_finished:
            message = "{{'file_hash':'{0}'}}".format(file_hash)
            connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ))
            channel = connection.channel()
            channel.queue_declare(queue='task_finished')
            channel.basic_publish(exchange='',
                                  routing_key='task_finished',
                                  body=message,
                                  properties=pika.BasicProperties(
                                  delivery_mode = 2, # make message persistent
                                  ))
        print 'wrote a task finished message to rabbitmq'
        
    
    
def consumer_thread_task():
    print 'starting task consumer thread'
    connection = pika.BlockingConnection(pika.ConnectionParameters(
        host=RABBITMQ))
    channel = connection.channel()
    channel.queue_declare(queue='cuckoo_modules_queue')
    channel.basic_consume(cuckoo_module_consume_callback,
                      queue='cuckoo_modules_queue')
    channel.start_consuming()

def run():
    consumer_thread = Thread(target=consumer_thread_task)
    consumer_thread.start()


if __name__ == '__main__':
    run()